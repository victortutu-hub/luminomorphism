/*! l-particle-net-ultra-protected.min.js - Advanced Protection Layer */
(function(){
  const now = Date.now();
  if (now < 1700000000000 || now > 2000000000000) return;

  const antiDebug = () => {
    const t1 = performance.now();
    debugger;
    const t2 = performance.now();
    return t2 - t1 > 5;
  };

  if (antiDebug()) {
    document.body.innerHTML = '';
    return;
  }

  const xor = (s, k) => s.split('').map((c, i) => String.fromCharCode(c.charCodeAt(0) ^ k.charCodeAt(i % k.length))).join('');

  const tagName = xor('\\x0e\\x0c\\x07\\x15\\x1e\\x11\\x14\\x0f\\x12\\x01\\x0d\\x14\\x01', 'key'); // 'l-particle-net'

  const C = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: 'open' });
      this.canvas = document.createElement('canvas');
      this.ctx = this.canvas.getContext('2d');
      this.shadowRoot.appendChild(this.canvas);
      this.nodes = [];
      this.mouse = { x: null, y: null };
      this.config = {
        count: parseInt(this.getAttribute('nodes')) || 32,
        maxDist: 120,
        radius: 2.8,
        glowColor: this.getAttribute('color') || '#00ffff',
        speed: parseFloat(this.getAttribute('speed')) || 0.4,
      };
    }

    connectedCallback() {
      this.resizeCanvas();
      window.addEventListener('resize', () => this.resizeCanvas());
      this.shadowRoot.host.addEventListener('pointermove', e => {
        const r = this.canvas.getBoundingClientRect();
        this.mouse.x = e.clientX - r.left;
        this.mouse.y = e.clientY - r.top;
      });
      this.shadowRoot.host.addEventListener('pointerleave', () => {
        this.mouse.x = this.mouse.y = null;
      });
      this.initNodes();
      requestAnimationFrame(() => this.animate());
    }

    resizeCanvas() {
      this.canvas.width = this.offsetWidth;
      this.canvas.height = this.offsetHeight;
    }

    initNodes() {
      const s = this.config.speed;
      this.nodes = Array.from({ length: this.config.count }, () => ({
        x: Math.random() * this.canvas.width,
        y: Math.random() * this.canvas.height,
        vx: (Math.random() - 0.5) * s,
        vy: (Math.random() - 0.5) * s,
      }));
    }

    reset() {
      this.config.count = parseInt(this.getAttribute('nodes')) || 32;
      this.config.speed = parseFloat(this.getAttribute('speed')) || 0.4;
      this.config.glowColor = this.getAttribute('color') || '#00ffff';
      this.initNodes();
    }

    animate() {
      const { ctx, canvas, config, nodes, mouse } = this;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let n of nodes) {
        n.x += n.vx;
        n.y += n.vy;
        if (n.x <= 0 || n.x >= canvas.width) n.vx *= -1;
        if (n.y <= 0 || n.y >= canvas.height) n.vy *= -1;
      }

      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const dx = nodes[i].x - nodes[j].x;
          const dy = nodes[i].y - nodes[j].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < config.maxDist) {
            const alpha = 1 - dist / config.maxDist;
            ctx.strokeStyle = `rgba(0,255,255,${alpha * 0.25})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(nodes[i].x, nodes[i].y);
            ctx.lineTo(nodes[j].x, nodes[j].y);
            ctx.stroke();
          }
        }

        if (mouse.x && mouse.y) {
          const dx = nodes[i].x - mouse.x;
          const dy = nodes[i].y - mouse.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < config.maxDist * 1.2) {
            const alpha = 1 - dist / (config.maxDist * 1.2);
            ctx.strokeStyle = `rgba(0,255,255,${alpha * 0.2})`;
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            ctx.moveTo(nodes[i].x, nodes[i].y);
            ctx.lineTo(mouse.x, mouse.y);
            ctx.stroke();
          }
        }
      }

      for (let n of nodes) {
        const gradient = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, config.radius * 4);
        gradient.addColorStop(0, `${config.glowColor}88`);
        gradient.addColorStop(1, '#00000000');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(n.x, n.y, config.radius, 0, Math.PI * 2);
        ctx.fill();
      }

      requestAnimationFrame(() => this.animate());
    }
  };

  customElements.define(tagName, C);
})();
