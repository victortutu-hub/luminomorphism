class LNeuralGrowth extends HTMLElement{constructor(){super();this.attachShadow({mode:"open"});this.cv$ = document.createElement("cv$");this.c$ = this.cv$.getContext("2d");this.shadowRoot.appendChild(this.cv$);this.b$ = [];this.s$ = [];this.tp$ = [];this.fc$ = 0;this.maxBranchLength = 80;this.cfg$ ={gs$:parseFloat(this.getAttribute("growth-speed"))|| 0.5,md$:parseInt(this.getAttribute("max-depth"))|| 5,ba$:parseFloat(this.getAttribute("branching-angle"))|| 0.5,sc$:0.12,st$:35,pf$:0.08};document.addEventListener("keydown",e =>{if(e.key.toLowerCase()=== "r")this.r$();});}cc$(){this.rC$();window.addEventListener("resize",()=> this.rC$());this.i$();this.a$();}rC$(){this.cv$.width = this.offsetWidth;this.cv$.height = this.offsetHeight;}i$(){const centerX = this.cv$.width / 2;const centerY = this.cv$.height / 2;this.b$ = [{x:centerX,y:centerY,angle:-Math.PI / 2,depth:0,length:2}];this.s$ = [];this.tp$ = [];this.fc$ = 0;}gB$(branch){let len = Math.min(branch.length + this.cfg$.gs$,this.maxBranchLength);const newX = branch.x + len * Math.cos(branch.angle);const newY = branch.y + len * Math.sin(branch.angle);if(newX < 0 || newX > this.cv$.width || newY < 0 || newY > this.cv$.height)return [];const newBranches = [];if(branch.depth < this.cfg$.md$){if(Math.random()< this.cfg$.sc$){const angle1 = branch.angle + this.cfg$.ba$;const angle2 = branch.angle - this.cfg$.ba$;newBranches.push({x:newX,y:newY,angle:angle1,depth:branch.depth + 1,length:1});newBranches.push({x:newX,y:newY,angle:angle2,depth:branch.depth + 1,length:1});}else{newBranches.push({x:newX,y:newY,angle:branch.angle,depth:branch.depth,length:len});}}else{this.tp$.push({x:newX,y:newY});}this.c$.beginPath();this.c$.moveTo(branch.x,branch.y);this.c$.lineTo(newX,newY);this.c$.strokeStyle = `rgba(0,255,255,${1 - branch.depth / this.cfg$.md$})`;this.c$.lineWidth = Math.max(1,3 - branch.depth);this.c$.stroke();return newBranches;}dS$(){const threshold = this.cfg$.st$;const newSynapses = [];for(let i = 0;i < this.tp$.length;i++){for(let j = i + 1;j < this.tp$.length;j++){const a = this.tp$[i];const b = this.tp$[j];const dx = a.x - b.x;const dy = a.y - b.y;const dist = Math.sqrt(dx * dx + dy * dy);if(dist < threshold)newSynapses.push({a,b});}}this.s$ = newSynapses;}drS$(){const alpha = 0.5 + 0.5 * Math.sin(this.fc$ * this.cfg$.pf$);this.c$.save();this.c$.shadowColor = "magenta";this.c$.shadowBlur = 12;this.c$.lineCap = "round";this.c$.lineWidth = 1.2;const r = 200 + Math.sin(this.fc$ * 0.1)* 55;const g = 80 + Math.sin(this.fc$ * 0.13 + 1)* 50;const b = 255;this.c$.strokeStyle = `rgba(${r},${g},${b},${alpha.toFixed(2)})`;for(const s of this.s$){this.c$.beginPath();this.c$.moveTo(s.a.x,s.a.y);this.c$.lineTo(s.b.x,s.b.y);this.c$.stroke();}this.c$.restore();}a$(){requestAnimationFrame(()=> this.a$());this.fc$++;const newBranches = [];this.tp$ = [];for(let i = 0;i < this.b$.length;i++){const result = this.gB$(this.b$[i]);newBranches.push(...result);}this.b$ = newBranches;if(this.b$.length === 0 && this.s$.length === 0){this.dS$();}this.drS$();}r$(){this.c$.clearRect(0,0,this.cv$.width,this.cv$.height);this.i$();}}customElements.define("l-neural-growth",LNeuralGrowth);